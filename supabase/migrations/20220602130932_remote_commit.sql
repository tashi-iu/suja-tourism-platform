-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
    SET search_path=public
AS $BODY$

begin
  insert into public.profiles (id)
  values (new.id);
  return new;
end;
$BODY$;

ALTER FUNCTION public.handle_new_user()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO anon;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO service_role;

CREATE TABLE IF NOT EXISTS public.likes
(
    post_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT likes_pkey PRIMARY KEY (post_id, profile_id),
    CONSTRAINT likes_post_id_fkey FOREIGN KEY (post_id)
        REFERENCES public.posts (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT likes_profile_id_fkey FOREIGN KEY (profile_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.likes
    OWNER to postgres;

ALTER TABLE IF EXISTS public.likes
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.likes TO authenticated;

GRANT ALL ON TABLE public.likes TO postgres;

GRANT ALL ON TABLE public.likes TO anon;

GRANT ALL ON TABLE public.likes TO service_role;

COMMENT ON TABLE public.likes
    IS 'Likes in posts and replies';
CREATE UNIQUE INDEX IF NOT EXISTS idx_like
    ON public.likes USING btree
    (profile_id ASC NULLS LAST, post_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Everyone can see the likes"
    ON public.likes
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only current user can create a like"
    ON public.likes
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = profile_id));
CREATE POLICY "Only current user can delete their like"
    ON public.likes
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = profile_id));
CREATE POLICY "Only current user can update their like"
    ON public.likes
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = profile_id));

CREATE TABLE IF NOT EXISTS public.posts
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    created_at timestamp with time zone DEFAULT now(),
    body text COLLATE pg_catalog."default" DEFAULT ''::text,
    updated_at timestamp with time zone,
    profile_id uuid NOT NULL,
    image_urls text[] COLLATE pg_catalog."default",
    CONSTRAINT posts_pkey PRIMARY KEY (id),
    CONSTRAINT posts_profile_id_fkey FOREIGN KEY (profile_id)
        REFERENCES public.profiles (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.posts
    OWNER to postgres;

ALTER TABLE IF EXISTS public.posts
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.posts TO authenticated;

GRANT ALL ON TABLE public.posts TO postgres;

GRANT ALL ON TABLE public.posts TO anon;

GRANT ALL ON TABLE public.posts TO service_role;

COMMENT ON TABLE public.posts
    IS 'User posts';
CREATE POLICY "Allow only the post creator to update the post."
    ON public.posts
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = profile_id));
CREATE POLICY "Only current user can delete their post"
    ON public.posts
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = profile_id));
CREATE POLICY "Users can create posts for themselves"
    ON public.posts
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = profile_id));
CREATE POLICY "Viewable by everyone"
    ON public.posts
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.presences
(
    profile_id uuid NOT NULL,
    last_seen timestamp with time zone DEFAULT now(),
    forced_offline boolean DEFAULT false,
    CONSTRAINT presences_pkey PRIMARY KEY (profile_id),
    CONSTRAINT presences_profile_id_fkey FOREIGN KEY (profile_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.presences
    OWNER to postgres;

ALTER TABLE IF EXISTS public.presences
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.presences TO authenticated;

GRANT ALL ON TABLE public.presences TO postgres;

GRANT ALL ON TABLE public.presences TO anon;

GRANT ALL ON TABLE public.presences TO service_role;

COMMENT ON TABLE public.presences
    IS 'User presence status';
CREATE POLICY "Anyone can see presences "
    ON public.presences
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only the row's user can create it's own row"
    ON public.presences
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = profile_id));
CREATE POLICY "Only user of row can delete it's row"
    ON public.presences
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = profile_id));
CREATE POLICY "Only user of the row can update it's on row"
    ON public.presences
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = profile_id))
    WITH CHECK ((auth.uid() = profile_id));

CREATE TABLE IF NOT EXISTS public.followers
(
    follower_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    following_id uuid NOT NULL,
    CONSTRAINT followers_pkey PRIMARY KEY (follower_id, following_id),
    CONSTRAINT followers_follower_id_fkey FOREIGN KEY (follower_id)
        REFERENCES public.profiles (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT followers_following_id_fkey FOREIGN KEY (following_id)
        REFERENCES public.profiles (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.followers
    OWNER to postgres;

ALTER TABLE IF EXISTS public.followers
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.followers TO authenticated;

GRANT ALL ON TABLE public.followers TO postgres;

GRANT ALL ON TABLE public.followers TO anon;

GRANT ALL ON TABLE public.followers TO service_role;

COMMENT ON TABLE public.followers
    IS 'User/Business followers and following';

CREATE TABLE IF NOT EXISTS public.messages
(
    sender_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    receiver_id uuid NOT NULL,
    updated_at timestamp with time zone,
    text text COLLATE pg_catalog."default",
    image_urls text[] COLLATE pg_catalog."default",
    voice_url text COLLATE pg_catalog."default",
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    CONSTRAINT messages_pkey PRIMARY KEY (sender_id, receiver_id, id),
    CONSTRAINT messages_receiver_id_fkey FOREIGN KEY (receiver_id)
        REFERENCES public.profiles (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT messages_sender_id_fkey FOREIGN KEY (sender_id)
        REFERENCES public.profiles (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.messages
    OWNER to postgres;

ALTER TABLE IF EXISTS public.messages
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.messages TO authenticated;

GRANT ALL ON TABLE public.messages TO postgres;

GRANT ALL ON TABLE public.messages TO anon;

GRANT ALL ON TABLE public.messages TO service_role;

COMMENT ON TABLE public.messages
    IS 'User/Business messages';
CREATE POLICY "Only sender and receiver can view their message"
    ON public.messages
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (((auth.uid() = sender_id) OR (auth.uid() = receiver_id)));
CREATE POLICY "Only sender can create a message"
    ON public.messages
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = sender_id));
CREATE POLICY "Only sender can delete their message "
    ON public.messages
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = sender_id));
CREATE POLICY "Only sender can update their message"
    ON public.messages
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = sender_id));

CREATE TABLE IF NOT EXISTS public.profiles
(
    id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    email text COLLATE pg_catalog."default",
    avatar_url text COLLATE pg_catalog."default",
    name text COLLATE pg_catalog."default",
    role text COLLATE pg_catalog."default",
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT profiles_id_fkey FOREIGN KEY (id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.profiles
    OWNER to postgres;

ALTER TABLE IF EXISTS public.profiles
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.profiles TO authenticated;

GRANT ALL ON TABLE public.profiles TO postgres;

GRANT ALL ON TABLE public.profiles TO anon;

GRANT ALL ON TABLE public.profiles TO service_role;

COMMENT ON TABLE public.profiles
    IS 'User profiles';
CREATE POLICY "Only user of the profile can delete "
    ON public.profiles
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = id));
CREATE POLICY "Public profiles are viewable by everyone."
    ON public.profiles
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Users can insert their own profile."
    ON public.profiles
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = id));
CREATE POLICY "Users can update own profile."
    ON public.profiles
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = id));

DROP FUNCTION IF EXISTS graphql.build_update(ast jsonb, variable_definitions jsonb, variables jsonb, parent_type text, parent_block_name text);

DROP FUNCTION IF EXISTS graphql.cache_key(role regrole, ast jsonb, variables jsonb);

DROP FUNCTION IF EXISTS graphql.build_insert(ast jsonb, variable_definitions jsonb, variables jsonb, parent_type text);

DROP FUNCTION IF EXISTS graphql.build_delete(ast jsonb, variable_definitions jsonb, variables jsonb, parent_type text, parent_block_name text);

DROP TABLE IF EXISTS graphql._type CASCADE;

DROP TABLE IF EXISTS graphql._field CASCADE;
